using Unity.Entities;
using Unity.Jobs;
using Unity.Transforms;
using Unity.Mathematics;

// 到达目的地
[UpdateInGroup(typeof(AgentSimulationSystemGroup))]
public partial class CheckReachedDestinationSystem : SystemBase
{
    private EndSimulationEntityCommandBufferSystem m_EndSimECBSystem;

    protected override void OnCreate()
    {
        m_EndSimECBSystem = World.GetExistingSystemManaged<EndSimulationEntityCommandBufferSystem>();
        this.Enabled = false;
    }

    protected override void OnUpdate()
    {
        // Create an ECB to record modification to entities that will only be executed at the end of the simulation group.
        var ecb = m_EndSimECBSystem.CreateCommandBuffer().AsParallelWriter();

        var destinationPos = GetSingleton<FlowFieldSettingData>().destination.xz;

        var escapedHadle = Entities.WithAll<Escaping>().ForEach((Entity e, int entityInQueryIndex, in LocalTransform localTransform) =>
        {
            var distanceSq = math.lengthsq(destinationPos - localTransform.Position.xz);
            if (distanceSq < 0.25f)// 距离出口0.5m时逃生结束
            {
                ecb.RemoveComponent<Escaping>(entityInQueryIndex, e);
                ecb.AddComponent<Escaped>(entityInQueryIndex, e);
                ecb.AddComponent<Disabled>(entityInQueryIndex, e);
            }
        }).ScheduleParallel(Dependency);

        // EntityCommandBufferSystems need to know about all jobs which write to EntityCommandBuffers it has created
        m_EndSimECBSystem.AddJobHandleForProducer(escapedHadle);

        // Pass the handle generated by the ForEach to the next system
        Dependency = escapedHadle;
    }
}
